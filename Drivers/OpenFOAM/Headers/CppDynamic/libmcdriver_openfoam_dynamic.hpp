/*++

Copyright (C) 2025 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver for the OpenFOAM CFD Solver

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_OPENFOAM_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_OPENFOAM_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_openfoam_types.hpp"
#include "libmcdriver_openfoam_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_OpenFOAM {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class COpenFOAMCase;
class CDriver_OpenFOAM;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_OpenFOAMWrapper;
typedef CBase CLibMCDriver_OpenFOAMBase;
typedef CDriver CLibMCDriver_OpenFOAMDriver;
typedef COpenFOAMCase CLibMCDriver_OpenFOAMOpenFOAMCase;
typedef CDriver_OpenFOAM CLibMCDriver_OpenFOAMDriver_OpenFOAM;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<COpenFOAMCase> POpenFOAMCase;
typedef std::shared_ptr<CDriver_OpenFOAM> PDriver_OpenFOAM;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_OpenFOAMWrapper;
typedef PBase PLibMCDriver_OpenFOAMBase;
typedef PDriver PLibMCDriver_OpenFOAMDriver;
typedef POpenFOAMCase PLibMCDriver_OpenFOAMOpenFOAMCase;
typedef PDriver_OpenFOAM PLibMCDriver_OpenFOAMDriver_OpenFOAM;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_OpenFOAMHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_OpenFOAMException 
**************************************************************************************************************************/
class ELibMCDriver_OpenFOAMException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_OpenFOAMResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_OpenFOAMException(LibMCDriver_OpenFOAMResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_OpenFOAMResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_OPENFOAM_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_OPENFOAM_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_OPENFOAM_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_OPENFOAM_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_OPENFOAM_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_OPENFOAM_ERROR_UNKNOWNIMAGEWRITEFORMAT: return "UNKNOWNIMAGEWRITEFORMAT";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTWRITEIMAGETODISK: return "COULDNOTWRITEIMAGETODISK";
			case LIBMCDRIVER_OPENFOAM_ERROR_EMPTYFILENAME: return "EMPTYFILENAME";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTCONVERTFILENAME: return "COULDNOTCONVERTFILENAME";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTGETSHORTPATHNAME: return "COULDNOTGETSHORTPATHNAME";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTCONVERTSHORTFILENAME: return "COULDNOTCONVERTSHORTFILENAME";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDCASEIDENTIFIER: return "INVALIDCASEIDENTIFIER";
			case LIBMCDRIVER_OPENFOAM_ERROR_CASEIDENTIFIERNOTFOUND: return "CASEIDENTIFIERNOTFOUND";
			case LIBMCDRIVER_OPENFOAM_ERROR_CASEIDENTIFIERALREADYEXISTS: return "CASEIDENTIFIERALREADYEXISTS";
			case LIBMCDRIVER_OPENFOAM_ERROR_CANNOTRUNOPENFOAMCASE: return "CANNOTRUNOPENFOAMCASE";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDOPENFOAMVERSION: return "INVALIDOPENFOAMVERSION";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDBLOCKMESHOUTBOX: return "INVALIDBLOCKMESHOUTBOX";
			case LIBMCDRIVER_OPENFOAM_ERROR_CASEDEFINITIONNOTINITIALIZED: return "CASEDEFINITIONNOTINITIALIZED";
			case LIBMCDRIVER_OPENFOAM_ERROR_MISSINGSURFACEIDENTIFIER: return "MISSINGSURFACEIDENTIFIER";
			case LIBMCDRIVER_OPENFOAM_ERROR_MISSINGSURFACEUUID: return "MISSINGSURFACEUUID";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACEIDENTIFIER: return "INVALIDSURFACEIDENTIFIER";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACEUUID: return "INVALIDSURFACEUUID";
			case LIBMCDRIVER_OPENFOAM_ERROR_MISSINGSURFACETYPE: return "MISSINGSURFACETYPE";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACEGROUP: return "INVALIDSURFACEGROUP";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACETYPE: return "INVALIDSURFACETYPE";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDOPENFOAMDEFINITION: return "INVALIDOPENFOAMDEFINITION";
			case LIBMCDRIVER_OPENFOAM_ERROR_DUPLICATEOPENFOAMSURFACE: return "DUPLICATEOPENFOAMSURFACE";
			case LIBMCDRIVER_OPENFOAM_ERROR_OPENFOAMDEFINITIONMISSINGINBUILD: return "OPENFOAMDEFINITIONMISSINGINBUILD";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDKEYCHARLENGTH: return "INVALIDKEYCHARLENGTH";
			case LIBMCDRIVER_OPENFOAM_ERROR_OPENFOAMDOMAINMUSTBECONNECTED: return "OPENFOAMDOMAINMUSTBECONNECTED";
			case LIBMCDRIVER_OPENFOAM_ERROR_SURFACESTLNOTFOUND: return "SURFACESTLNOTFOUND";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_OPENFOAM_SUCCESS: return "success";
			case LIBMCDRIVER_OPENFOAM_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_OPENFOAM_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_OPENFOAM_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_OPENFOAM_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_OPENFOAM_ERROR_UNKNOWNIMAGEWRITEFORMAT: return "unknown image write format";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTWRITEIMAGETODISK: return "could not write image to disk";
			case LIBMCDRIVER_OPENFOAM_ERROR_EMPTYFILENAME: return "empty file name";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTCONVERTFILENAME: return "could not convert filename";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTGETSHORTPATHNAME: return "could not get short path name";
			case LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTCONVERTSHORTFILENAME: return "could not convert short path name";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDCASEIDENTIFIER: return "invalid case identifier";
			case LIBMCDRIVER_OPENFOAM_ERROR_CASEIDENTIFIERNOTFOUND: return "case identifier not found";
			case LIBMCDRIVER_OPENFOAM_ERROR_CASEIDENTIFIERALREADYEXISTS: return "case identifier already exists";
			case LIBMCDRIVER_OPENFOAM_ERROR_CANNOTRUNOPENFOAMCASE: return "can not run OpenFOAM case";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDOPENFOAMVERSION: return "invalid OpenFOAM Version";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDBLOCKMESHOUTBOX: return "invalid Block Mesh Outbox";
			case LIBMCDRIVER_OPENFOAM_ERROR_CASEDEFINITIONNOTINITIALIZED: return "Case definition not initialized";
			case LIBMCDRIVER_OPENFOAM_ERROR_MISSINGSURFACEIDENTIFIER: return "Missing surface identifier";
			case LIBMCDRIVER_OPENFOAM_ERROR_MISSINGSURFACEUUID: return "Missing surface UUID";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACEIDENTIFIER: return "Invalid surface identifier";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACEUUID: return "Invalid surface identifier";
			case LIBMCDRIVER_OPENFOAM_ERROR_MISSINGSURFACETYPE: return "Missing surface type";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACEGROUP: return "Invalid surface group";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDSURFACETYPE: return "Invalid surface type";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDOPENFOAMDEFINITION: return "Invalid OpenFOAM Definition";
			case LIBMCDRIVER_OPENFOAM_ERROR_DUPLICATEOPENFOAMSURFACE: return "Duplicate OpenFOAM Surface";
			case LIBMCDRIVER_OPENFOAM_ERROR_OPENFOAMDEFINITIONMISSINGINBUILD: return "OpenFOAM Definition missing in build.";
			case LIBMCDRIVER_OPENFOAM_ERROR_INVALIDKEYCHARLENGTH: return "Invalid key char length";
			case LIBMCDRIVER_OPENFOAM_ERROR_OPENFOAMDOMAINMUSTBECONNECTED: return "OpenFOAM Domain must be connected.";
			case LIBMCDRIVER_OPENFOAM_ERROR_SURFACESTLNOTFOUND: return "Surface STL not found.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_OpenFOAMInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_OpenFOAMResult nResult);

	inline void GetVersion(LibMCDriver_OpenFOAM_uint32 & nMajor, LibMCDriver_OpenFOAM_uint32 & nMinor, LibMCDriver_OpenFOAM_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_OpenFOAM_pvoid pSymbolAddressMethod);
	inline LibMCDriver_OpenFOAM_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_OpenFOAMDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_OpenFOAMResult checkBinaryVersion()
	{
		LibMCDriver_OpenFOAM_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_OPENFOAM_VERSION_MAJOR) {
			return LIBMCDRIVER_OPENFOAM_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_OPENFOAM_SUCCESS;
	}
	LibMCDriver_OpenFOAMResult initWrapperTable(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable);
	LibMCDriver_OpenFOAMResult releaseWrapperTable(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable);
	LibMCDriver_OpenFOAMResult loadWrapperTable(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_OpenFOAMResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class COpenFOAMCase;
	friend class CDriver_OpenFOAM;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_OpenFOAMHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_OpenFOAMResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_OpenFOAMHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_OpenFOAMHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_OpenFOAMHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_OpenFOAM_uint32 & nMajor, LibMCDriver_OpenFOAM_uint32 & nMinor, LibMCDriver_OpenFOAM_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class COpenFOAMCase 
**************************************************************************************************************************/
class COpenFOAMCase : public CBase {
public:
	
	/**
	* COpenFOAMCase::COpenFOAMCase - Constructor for OpenFOAMCase class.
	*/
	COpenFOAMCase(CWrapper* pWrapper, LibMCDriver_OpenFOAMHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetIdentifier();
	inline bool CanRun();
	inline eCaseStatus GetStatus();
	inline bool IsRunning();
	inline bool IsSuccessful();
	inline bool IsInError();
	inline void SetBuild(classParam<LibMCEnv::CBuild> pBuild);
	inline bool HasBuild();
	inline std::string GetBuildUUID();
	inline void StartComputation();
	inline void CreateOpenFOAMInputDeck(classParam<LibMCEnv::CZIPStreamWriter> pZIPStream);
};
	
/*************************************************************************************************************************
 Class CDriver_OpenFOAM 
**************************************************************************************************************************/
class CDriver_OpenFOAM : public CDriver {
public:
	
	/**
	* CDriver_OpenFOAM::CDriver_OpenFOAM - Constructor for Driver_OpenFOAM class.
	*/
	CDriver_OpenFOAM(CWrapper* pWrapper, LibMCDriver_OpenFOAMHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline POpenFOAMCase CreateCase(const std::string & sIdentifier);
	inline bool CaseExists(const std::string & sIdentifier);
	inline POpenFOAMCase FindCase(const std::string & sIdentifier);
	inline void ReleaseCase(const std::string & sIdentifier);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_OpenFOAM_uint32 & nMajor, LibMCDriver_OpenFOAM_uint32 & nMinor, LibMCDriver_OpenFOAM_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_OpenFOAMHandle hInstance = pInstance.GetHandle();
		LibMCDriver_OpenFOAM_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_OpenFOAM_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_OpenFOAMHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_OpenFOAMHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_OpenFOAM_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_OpenFOAMException(LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_OpenFOAMException(LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_OpenFOAM_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_OpenFOAM_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_OpenFOAMHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_OpenFOAMResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_OpenFOAMException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_OpenFOAMResult CWrapper::initWrapperTable(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_OpenFOAMCase_GetIdentifier = nullptr;
		pWrapperTable->m_OpenFOAMCase_CanRun = nullptr;
		pWrapperTable->m_OpenFOAMCase_GetStatus = nullptr;
		pWrapperTable->m_OpenFOAMCase_IsRunning = nullptr;
		pWrapperTable->m_OpenFOAMCase_IsSuccessful = nullptr;
		pWrapperTable->m_OpenFOAMCase_IsInError = nullptr;
		pWrapperTable->m_OpenFOAMCase_SetBuild = nullptr;
		pWrapperTable->m_OpenFOAMCase_HasBuild = nullptr;
		pWrapperTable->m_OpenFOAMCase_GetBuildUUID = nullptr;
		pWrapperTable->m_OpenFOAMCase_StartComputation = nullptr;
		pWrapperTable->m_OpenFOAMCase_CreateOpenFOAMInputDeck = nullptr;
		pWrapperTable->m_Driver_OpenFOAM_CreateCase = nullptr;
		pWrapperTable->m_Driver_OpenFOAM_CaseExists = nullptr;
		pWrapperTable->m_Driver_OpenFOAM_FindCase = nullptr;
		pWrapperTable->m_Driver_OpenFOAM_ReleaseCase = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_OPENFOAM_SUCCESS;
	}

	inline LibMCDriver_OpenFOAMResult CWrapper::releaseWrapperTable(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_OPENFOAM_SUCCESS;
	}

	inline LibMCDriver_OpenFOAMResult CWrapper::loadWrapperTable(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_OpenFOAMDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_OpenFOAMDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_OpenFOAMDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_OpenFOAMDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_OpenFOAMDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_OpenFOAMDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_OpenFOAMDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_OpenFOAMDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_OpenFOAMDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_OpenFOAMDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_OpenFOAMDriver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_OpenFOAMDriver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_GetIdentifier = (PLibMCDriver_OpenFOAMOpenFOAMCase_GetIdentifierPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_getidentifier");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_GetIdentifier = (PLibMCDriver_OpenFOAMOpenFOAMCase_GetIdentifierPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_getidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_GetIdentifier == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_CanRun = (PLibMCDriver_OpenFOAMOpenFOAMCase_CanRunPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_canrun");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_CanRun = (PLibMCDriver_OpenFOAMOpenFOAMCase_CanRunPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_canrun");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_CanRun == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_GetStatus = (PLibMCDriver_OpenFOAMOpenFOAMCase_GetStatusPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_getstatus");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_GetStatus = (PLibMCDriver_OpenFOAMOpenFOAMCase_GetStatusPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_GetStatus == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_IsRunning = (PLibMCDriver_OpenFOAMOpenFOAMCase_IsRunningPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_isrunning");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_IsRunning = (PLibMCDriver_OpenFOAMOpenFOAMCase_IsRunningPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_isrunning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_IsRunning == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_IsSuccessful = (PLibMCDriver_OpenFOAMOpenFOAMCase_IsSuccessfulPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_issuccessful");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_IsSuccessful = (PLibMCDriver_OpenFOAMOpenFOAMCase_IsSuccessfulPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_issuccessful");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_IsSuccessful == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_IsInError = (PLibMCDriver_OpenFOAMOpenFOAMCase_IsInErrorPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_isinerror");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_IsInError = (PLibMCDriver_OpenFOAMOpenFOAMCase_IsInErrorPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_isinerror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_IsInError == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_SetBuild = (PLibMCDriver_OpenFOAMOpenFOAMCase_SetBuildPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_setbuild");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_SetBuild = (PLibMCDriver_OpenFOAMOpenFOAMCase_SetBuildPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_setbuild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_SetBuild == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_HasBuild = (PLibMCDriver_OpenFOAMOpenFOAMCase_HasBuildPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_hasbuild");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_HasBuild = (PLibMCDriver_OpenFOAMOpenFOAMCase_HasBuildPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_hasbuild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_HasBuild == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_GetBuildUUID = (PLibMCDriver_OpenFOAMOpenFOAMCase_GetBuildUUIDPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_getbuilduuid");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_GetBuildUUID = (PLibMCDriver_OpenFOAMOpenFOAMCase_GetBuildUUIDPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_getbuilduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_GetBuildUUID == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_StartComputation = (PLibMCDriver_OpenFOAMOpenFOAMCase_StartComputationPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_startcomputation");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_StartComputation = (PLibMCDriver_OpenFOAMOpenFOAMCase_StartComputationPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_startcomputation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_StartComputation == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OpenFOAMCase_CreateOpenFOAMInputDeck = (PLibMCDriver_OpenFOAMOpenFOAMCase_CreateOpenFOAMInputDeckPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_openfoamcase_createopenfoaminputdeck");
		#else // _WIN32
		pWrapperTable->m_OpenFOAMCase_CreateOpenFOAMInputDeck = (PLibMCDriver_OpenFOAMOpenFOAMCase_CreateOpenFOAMInputDeckPtr) dlsym(hLibrary, "libmcdriver_openfoam_openfoamcase_createopenfoaminputdeck");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OpenFOAMCase_CreateOpenFOAMInputDeck == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_OpenFOAM_CreateCase = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_CreateCasePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_openfoam_createcase");
		#else // _WIN32
		pWrapperTable->m_Driver_OpenFOAM_CreateCase = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_CreateCasePtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_openfoam_createcase");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_OpenFOAM_CreateCase == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_OpenFOAM_CaseExists = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_CaseExistsPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_openfoam_caseexists");
		#else // _WIN32
		pWrapperTable->m_Driver_OpenFOAM_CaseExists = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_CaseExistsPtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_openfoam_caseexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_OpenFOAM_CaseExists == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_OpenFOAM_FindCase = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_FindCasePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_openfoam_findcase");
		#else // _WIN32
		pWrapperTable->m_Driver_OpenFOAM_FindCase = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_FindCasePtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_openfoam_findcase");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_OpenFOAM_FindCase == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_OpenFOAM_ReleaseCase = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_ReleaseCasePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_driver_openfoam_releasecase");
		#else // _WIN32
		pWrapperTable->m_Driver_OpenFOAM_ReleaseCase = (PLibMCDriver_OpenFOAMDriver_OpenFOAM_ReleaseCasePtr) dlsym(hLibrary, "libmcdriver_openfoam_driver_openfoam_releasecase");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_OpenFOAM_ReleaseCase == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_OpenFOAMGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_OpenFOAMGetVersionPtr) dlsym(hLibrary, "libmcdriver_openfoam_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_OpenFOAMGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_OpenFOAMGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_openfoam_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_OpenFOAMReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_OpenFOAMReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_openfoam_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_OpenFOAMAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_OpenFOAMAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_openfoam_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_OpenFOAMInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_OpenFOAMInjectComponentPtr) dlsym(hLibrary, "libmcdriver_openfoam_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_OpenFOAMGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_OpenFOAMGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_openfoam_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_OpenFOAMCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_openfoam_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_OpenFOAMCreateDriverPtr) dlsym(hLibrary, "libmcdriver_openfoam_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_OPENFOAM_SUCCESS;
	}

	inline LibMCDriver_OpenFOAMResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_OpenFOAMDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_OpenFOAMResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_OpenFOAMResult eLookupError = LIBMCDRIVER_OPENFOAM_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_getidentifier", (void**)&(pWrapperTable->m_OpenFOAMCase_GetIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_GetIdentifier == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_canrun", (void**)&(pWrapperTable->m_OpenFOAMCase_CanRun));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_CanRun == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_getstatus", (void**)&(pWrapperTable->m_OpenFOAMCase_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_GetStatus == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_isrunning", (void**)&(pWrapperTable->m_OpenFOAMCase_IsRunning));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_IsRunning == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_issuccessful", (void**)&(pWrapperTable->m_OpenFOAMCase_IsSuccessful));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_IsSuccessful == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_isinerror", (void**)&(pWrapperTable->m_OpenFOAMCase_IsInError));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_IsInError == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_setbuild", (void**)&(pWrapperTable->m_OpenFOAMCase_SetBuild));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_SetBuild == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_hasbuild", (void**)&(pWrapperTable->m_OpenFOAMCase_HasBuild));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_HasBuild == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_getbuilduuid", (void**)&(pWrapperTable->m_OpenFOAMCase_GetBuildUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_GetBuildUUID == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_startcomputation", (void**)&(pWrapperTable->m_OpenFOAMCase_StartComputation));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_StartComputation == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_openfoamcase_createopenfoaminputdeck", (void**)&(pWrapperTable->m_OpenFOAMCase_CreateOpenFOAMInputDeck));
		if ( (eLookupError != 0) || (pWrapperTable->m_OpenFOAMCase_CreateOpenFOAMInputDeck == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_openfoam_createcase", (void**)&(pWrapperTable->m_Driver_OpenFOAM_CreateCase));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_OpenFOAM_CreateCase == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_openfoam_caseexists", (void**)&(pWrapperTable->m_Driver_OpenFOAM_CaseExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_OpenFOAM_CaseExists == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_openfoam_findcase", (void**)&(pWrapperTable->m_Driver_OpenFOAM_FindCase));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_OpenFOAM_FindCase == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_driver_openfoam_releasecase", (void**)&(pWrapperTable->m_Driver_OpenFOAM_ReleaseCase));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_OpenFOAM_ReleaseCase == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_openfoam_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_OPENFOAM_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_OPENFOAM_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_OpenFOAM_uint32 bytesNeededName = 0;
		LibMCDriver_OpenFOAM_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_OpenFOAM_uint32 bytesNeededType = 0;
		LibMCDriver_OpenFOAM_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_OpenFOAM_uint32 & nMajor, LibMCDriver_OpenFOAM_uint32 & nMinor, LibMCDriver_OpenFOAM_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_OpenFOAM_uint32 bytesNeededBuild = 0;
		LibMCDriver_OpenFOAM_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class COpenFOAMCase
	 */
	
	/**
	* COpenFOAMCase::GetIdentifier - Returns the identifier of the case.
	* @return Identifier string.
	*/
	std::string COpenFOAMCase::GetIdentifier()
	{
		LibMCDriver_OpenFOAM_uint32 bytesNeededIdentifier = 0;
		LibMCDriver_OpenFOAM_uint32 bytesWrittenIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_GetIdentifier(m_pHandle, 0, &bytesNeededIdentifier, nullptr));
		std::vector<char> bufferIdentifier(bytesNeededIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_GetIdentifier(m_pHandle, bytesNeededIdentifier, &bytesWrittenIdentifier, &bufferIdentifier[0]));
		
		return std::string(&bufferIdentifier[0]);
	}
	
	/**
	* COpenFOAMCase::CanRun - Returns if all prerequisites of the case have been set up and the case is not running yet.
	* @return Returns true if the case can run, false if it can not.
	*/
	bool COpenFOAMCase::CanRun()
	{
		bool resultCanRunFlag = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_CanRun(m_pHandle, &resultCanRunFlag));
		
		return resultCanRunFlag;
	}
	
	/**
	* COpenFOAMCase::GetStatus - Returns the current case status.
	* @return Returns the status variable.
	*/
	eCaseStatus COpenFOAMCase::GetStatus()
	{
		eCaseStatus resultStatus = (eCaseStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_GetStatus(m_pHandle, &resultStatus));
		
		return resultStatus;
	}
	
	/**
	* COpenFOAMCase::IsRunning - Returns if the case is running in the background.
	* @return Returns true if the case is currently running, false if is not running.
	*/
	bool COpenFOAMCase::IsRunning()
	{
		bool resultIsRunningFlag = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_IsRunning(m_pHandle, &resultIsRunningFlag));
		
		return resultIsRunningFlag;
	}
	
	/**
	* COpenFOAMCase::IsSuccessful - Returns if the case has finished successfully.
	* @return Returns true if the case has been computed successfully, false otherwise.
	*/
	bool COpenFOAMCase::IsSuccessful()
	{
		bool resultIsSuccessfulFlag = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_IsSuccessful(m_pHandle, &resultIsSuccessfulFlag));
		
		return resultIsSuccessfulFlag;
	}
	
	/**
	* COpenFOAMCase::IsInError - Returns if the case has finished with an error.
	* @return Returns true if the case has not been able to finish successfully, false otherwise. If the case has not been started, also false is returned.
	*/
	bool COpenFOAMCase::IsInError()
	{
		bool resultIsErrorFlag = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_IsInError(m_pHandle, &resultIsErrorFlag));
		
		return resultIsErrorFlag;
	}
	
	/**
	* COpenFOAMCase::SetBuild - Sets the simulation setup build.
	* @param[in] pBuild - Build instance to use.
	*/
	void COpenFOAMCase::SetBuild(classParam<LibMCEnv::CBuild> pBuild)
	{
		LibMCEnvHandle hBuild = pBuild.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_SetBuild(m_pHandle, hBuild));
	}
	
	/**
	* COpenFOAMCase::HasBuild - Has a build job associated with the case.
	* @return Returns true, if the case has an associated build job.
	*/
	bool COpenFOAMCase::HasBuild()
	{
		bool resultHasBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_HasBuild(m_pHandle, &resultHasBuild));
		
		return resultHasBuild;
	}
	
	/**
	* COpenFOAMCase::GetBuildUUID - Returns UUID of the build.
	* @return Build job UUID.
	*/
	std::string COpenFOAMCase::GetBuildUUID()
	{
		LibMCDriver_OpenFOAM_uint32 bytesNeededBuildUUID = 0;
		LibMCDriver_OpenFOAM_uint32 bytesWrittenBuildUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_GetBuildUUID(m_pHandle, 0, &bytesNeededBuildUUID, nullptr));
		std::vector<char> bufferBuildUUID(bytesNeededBuildUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_GetBuildUUID(m_pHandle, bytesNeededBuildUUID, &bytesWrittenBuildUUID, &bufferBuildUUID[0]));
		
		return std::string(&bufferBuildUUID[0]);
	}
	
	/**
	* COpenFOAMCase::StartComputation - Starts the computation. Fails if CanRun would return false.
	*/
	void COpenFOAMCase::StartComputation()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_StartComputation(m_pHandle));
	}
	
	/**
	* COpenFOAMCase::CreateOpenFOAMInputDeck - Writes the OpenFOAM input deck into a ZIP file
	* @param[in] pZIPStream - ZIP Stream writer to add the input deck to.
	*/
	void COpenFOAMCase::CreateOpenFOAMInputDeck(classParam<LibMCEnv::CZIPStreamWriter> pZIPStream)
	{
		LibMCEnvHandle hZIPStream = pZIPStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_OpenFOAMCase_CreateOpenFOAMInputDeck(m_pHandle, hZIPStream));
	}
	
	/**
	 * Method definitions for class CDriver_OpenFOAM
	 */
	
	/**
	* CDriver_OpenFOAM::CreateCase - Creates an open foam case. Fails if a case with the same identifier already exists.
	* @param[in] sIdentifier - Identifier of the case. MUST be an alphanumeric string with _ allowed. MUST not exceed 128 characters.
	* @return FOAM Case instance.
	*/
	POpenFOAMCase CDriver_OpenFOAM::CreateCase(const std::string & sIdentifier)
	{
		LibMCDriver_OpenFOAMHandle hCaseInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_OpenFOAM_CreateCase(m_pHandle, sIdentifier.c_str(), &hCaseInstance));
		
		if (!hCaseInstance) {
			CheckError(LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COpenFOAMCase>(m_pWrapper, hCaseInstance);
	}
	
	/**
	* CDriver_OpenFOAM::CaseExists - Checks if a case of a certain identifier exists.
	* @param[in] sIdentifier - Identifier of the case. MUST be an alphanumeric string with _ allowed. MUST not exceed 128 characters.
	* @return Returns true, if the case exists, false otherwise.
	*/
	bool CDriver_OpenFOAM::CaseExists(const std::string & sIdentifier)
	{
		bool resultCaseDoesExist = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_OpenFOAM_CaseExists(m_pHandle, sIdentifier.c_str(), &resultCaseDoesExist));
		
		return resultCaseDoesExist;
	}
	
	/**
	* CDriver_OpenFOAM::FindCase - Finds a case by a certain identifier. Fails if the case does not exist.
	* @param[in] sIdentifier - Identifier of the case. MUST be an alphanumeric string with _ allowed. MUST not exceed 128 characters.
	* @return FOAM Case instance.
	*/
	POpenFOAMCase CDriver_OpenFOAM::FindCase(const std::string & sIdentifier)
	{
		LibMCDriver_OpenFOAMHandle hCaseInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_OpenFOAM_FindCase(m_pHandle, sIdentifier.c_str(), &hCaseInstance));
		
		if (!hCaseInstance) {
			CheckError(LIBMCDRIVER_OPENFOAM_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COpenFOAMCase>(m_pWrapper, hCaseInstance);
	}
	
	/**
	* CDriver_OpenFOAM::ReleaseCase - Releases the case, frees all of its references and memory and removes the working directory from disk. Cancels any ongoing computation. Does nothing, if case does not exist.
	* @param[in] sIdentifier - Identifier of the case. MUST be an alphanumeric string with _ allowed. MUST not exceed 128 characters.
	*/
	void CDriver_OpenFOAM::ReleaseCase(const std::string & sIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_OpenFOAM_ReleaseCase(m_pHandle, sIdentifier.c_str()));
	}

} // namespace LibMCDriver_OpenFOAM

#endif // __LIBMCDRIVER_OPENFOAM_CPPHEADER_DYNAMIC_CPP

