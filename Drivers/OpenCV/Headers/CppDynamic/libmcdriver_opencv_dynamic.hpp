/*++

Copyright (C) 2025 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver for OpenCV Computer Vision Library

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_OPENCV_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_OPENCV_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_opencv_types.hpp"
#include "libmcdriver_opencv_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_OpenCV {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CImageSaveParameters;
class CImageBuffer;
class CMat;
class CDriver_OpenCV;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_OpenCVWrapper;
typedef CBase CLibMCDriver_OpenCVBase;
typedef CDriver CLibMCDriver_OpenCVDriver;
typedef CImageSaveParameters CLibMCDriver_OpenCVImageSaveParameters;
typedef CImageBuffer CLibMCDriver_OpenCVImageBuffer;
typedef CMat CLibMCDriver_OpenCVMat;
typedef CDriver_OpenCV CLibMCDriver_OpenCVDriver_OpenCV;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CImageSaveParameters> PImageSaveParameters;
typedef std::shared_ptr<CImageBuffer> PImageBuffer;
typedef std::shared_ptr<CMat> PMat;
typedef std::shared_ptr<CDriver_OpenCV> PDriver_OpenCV;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_OpenCVWrapper;
typedef PBase PLibMCDriver_OpenCVBase;
typedef PDriver PLibMCDriver_OpenCVDriver;
typedef PImageSaveParameters PLibMCDriver_OpenCVImageSaveParameters;
typedef PImageBuffer PLibMCDriver_OpenCVImageBuffer;
typedef PMat PLibMCDriver_OpenCVMat;
typedef PDriver_OpenCV PLibMCDriver_OpenCVDriver_OpenCV;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_OpenCVHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_OpenCVException 
**************************************************************************************************************************/
class ELibMCDriver_OpenCVException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_OpenCVResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_OpenCVException(LibMCDriver_OpenCVResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_OpenCVResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_OPENCV_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_OPENCV_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_OPENCV_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_OPENCV_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_OPENCV_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_OPENCV_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_OPENCV_ERROR_UNKNOWNIMAGEWRITEFORMAT: return "UNKNOWNIMAGEWRITEFORMAT";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTWRITEIMAGETODISK: return "COULDNOTWRITEIMAGETODISK";
			case LIBMCDRIVER_OPENCV_ERROR_EMPTYFILENAME: return "EMPTYFILENAME";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTCONVERTFILENAME: return "COULDNOTCONVERTFILENAME";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTGETSHORTPATHNAME: return "COULDNOTGETSHORTPATHNAME";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTCONVERTSHORTFILENAME: return "COULDNOTCONVERTSHORTFILENAME";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_OPENCV_SUCCESS: return "success";
			case LIBMCDRIVER_OPENCV_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_OPENCV_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_OPENCV_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_OPENCV_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_OPENCV_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_OPENCV_ERROR_UNKNOWNIMAGEWRITEFORMAT: return "unknown image write format";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTWRITEIMAGETODISK: return "could not write image to disk";
			case LIBMCDRIVER_OPENCV_ERROR_EMPTYFILENAME: return "empty file name";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTCONVERTFILENAME: return "could not convert filename";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTGETSHORTPATHNAME: return "could not get short path name";
			case LIBMCDRIVER_OPENCV_ERROR_COULDNOTCONVERTSHORTFILENAME: return "could not convert short path name";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_OpenCVInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_OpenCVResult nResult);

	inline void GetVersion(LibMCDriver_OpenCV_uint32 & nMajor, LibMCDriver_OpenCV_uint32 & nMinor, LibMCDriver_OpenCV_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_OpenCV_pvoid pSymbolAddressMethod);
	inline LibMCDriver_OpenCV_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_OpenCVDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_OpenCVResult checkBinaryVersion()
	{
		LibMCDriver_OpenCV_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_OPENCV_VERSION_MAJOR) {
			return LIBMCDRIVER_OPENCV_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_OPENCV_SUCCESS;
	}
	LibMCDriver_OpenCVResult initWrapperTable(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable);
	LibMCDriver_OpenCVResult releaseWrapperTable(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable);
	LibMCDriver_OpenCVResult loadWrapperTable(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_OpenCVResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CImageSaveParameters;
	friend class CImageBuffer;
	friend class CMat;
	friend class CDriver_OpenCV;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_OpenCVHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_OpenCVResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_OpenCVHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_OpenCVHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_OpenCVHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_OpenCV_uint32 & nMajor, LibMCDriver_OpenCV_uint32 & nMinor, LibMCDriver_OpenCV_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class CImageSaveParameters 
**************************************************************************************************************************/
class CImageSaveParameters : public CBase {
public:
	
	/**
	* CImageSaveParameters::CImageSaveParameters - Constructor for ImageSaveParameters class.
	*/
	CImageSaveParameters(CWrapper* pWrapper, LibMCDriver_OpenCVHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
};
	
/*************************************************************************************************************************
 Class CImageBuffer 
**************************************************************************************************************************/
class CImageBuffer : public CBase {
public:
	
	/**
	* CImageBuffer::CImageBuffer - Constructor for ImageBuffer class.
	*/
	CImageBuffer(CWrapper* pWrapper, LibMCDriver_OpenCVHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline eImageWriteFormat GetImageFormat();
	inline LibMCDriver_OpenCV_uint64 GetSize();
	inline void GetData(std::vector<LibMCDriver_OpenCV_uint8> & MemoryArrayBuffer);
	inline void StoreToStream(classParam<LibMCEnv::CTempStreamWriter> pStream);
};
	
/*************************************************************************************************************************
 Class CMat 
**************************************************************************************************************************/
class CMat : public CBase {
public:
	
	/**
	* CMat::CMat - Constructor for Mat class.
	*/
	CMat(CWrapper* pWrapper, LibMCDriver_OpenCVHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool Empty();
	inline LibMCDriver_OpenCV_uint32 Cols();
	inline LibMCDriver_OpenCV_uint32 Rows();
	inline PImageBuffer EncodeImage(const eImageWriteFormat eWriteFormat, classParam<CImageSaveParameters> pSaveParameters);
	inline void EncodeImageToStream(const eImageWriteFormat eWriteFormat, classParam<CImageSaveParameters> pSaveParameters, classParam<LibMCEnv::CTempStreamWriter> pStream);
};
	
/*************************************************************************************************************************
 Class CDriver_OpenCV 
**************************************************************************************************************************/
class CDriver_OpenCV : public CDriver {
public:
	
	/**
	* CDriver_OpenCV::CDriver_OpenCV - Constructor for Driver_OpenCV class.
	*/
	CDriver_OpenCV(CWrapper* pWrapper, LibMCDriver_OpenCVHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline PMat LoadImageFromBuffer(const CInputVector<LibMCDriver_OpenCV_uint8> & BufferBuffer, const eImageReadFormat eReadFormat);
	inline PMat LoadImageFromResource(const std::string & sResourceIdentifier, const eImageReadFormat eReadFormat);
	inline PMat CreateEmptyImage(const LibMCDriver_OpenCV_uint32 nColumnCount, const LibMCDriver_OpenCV_uint32 nRowCount, const eImageReadFormat eReadFormat);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_OpenCV_uint32 & nMajor, LibMCDriver_OpenCV_uint32 & nMinor, LibMCDriver_OpenCV_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_OpenCVHandle hInstance = pInstance.GetHandle();
		LibMCDriver_OpenCV_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_OpenCV_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_OpenCVHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_OpenCVHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_OpenCV_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_OpenCVException(LIBMCDRIVER_OPENCV_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_OpenCVException(LIBMCDRIVER_OPENCV_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_OpenCV_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_OpenCV_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_OpenCVHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_OpenCVResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_OpenCVException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_OpenCVResult CWrapper::initWrapperTable(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_ImageBuffer_GetImageFormat = nullptr;
		pWrapperTable->m_ImageBuffer_GetSize = nullptr;
		pWrapperTable->m_ImageBuffer_GetData = nullptr;
		pWrapperTable->m_ImageBuffer_StoreToStream = nullptr;
		pWrapperTable->m_Mat_Empty = nullptr;
		pWrapperTable->m_Mat_Cols = nullptr;
		pWrapperTable->m_Mat_Rows = nullptr;
		pWrapperTable->m_Mat_EncodeImage = nullptr;
		pWrapperTable->m_Mat_EncodeImageToStream = nullptr;
		pWrapperTable->m_Driver_OpenCV_LoadImageFromBuffer = nullptr;
		pWrapperTable->m_Driver_OpenCV_LoadImageFromResource = nullptr;
		pWrapperTable->m_Driver_OpenCV_CreateEmptyImage = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_OPENCV_SUCCESS;
	}

	inline LibMCDriver_OpenCVResult CWrapper::releaseWrapperTable(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_OPENCV_SUCCESS;
	}

	inline LibMCDriver_OpenCVResult CWrapper::loadWrapperTable(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_OpenCVDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_OpenCVDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_opencv_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_OpenCVDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_OpenCVDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_opencv_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_OpenCVDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_OpenCVDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_opencv_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_OpenCVDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_OpenCVDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_opencv_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_OpenCVDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_OpenCVDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_opencv_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_OpenCVDriver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_OpenCVDriver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_opencv_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageBuffer_GetImageFormat = (PLibMCDriver_OpenCVImageBuffer_GetImageFormatPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_imagebuffer_getimageformat");
		#else // _WIN32
		pWrapperTable->m_ImageBuffer_GetImageFormat = (PLibMCDriver_OpenCVImageBuffer_GetImageFormatPtr) dlsym(hLibrary, "libmcdriver_opencv_imagebuffer_getimageformat");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageBuffer_GetImageFormat == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageBuffer_GetSize = (PLibMCDriver_OpenCVImageBuffer_GetSizePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_imagebuffer_getsize");
		#else // _WIN32
		pWrapperTable->m_ImageBuffer_GetSize = (PLibMCDriver_OpenCVImageBuffer_GetSizePtr) dlsym(hLibrary, "libmcdriver_opencv_imagebuffer_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageBuffer_GetSize == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageBuffer_GetData = (PLibMCDriver_OpenCVImageBuffer_GetDataPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_imagebuffer_getdata");
		#else // _WIN32
		pWrapperTable->m_ImageBuffer_GetData = (PLibMCDriver_OpenCVImageBuffer_GetDataPtr) dlsym(hLibrary, "libmcdriver_opencv_imagebuffer_getdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageBuffer_GetData == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageBuffer_StoreToStream = (PLibMCDriver_OpenCVImageBuffer_StoreToStreamPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_imagebuffer_storetostream");
		#else // _WIN32
		pWrapperTable->m_ImageBuffer_StoreToStream = (PLibMCDriver_OpenCVImageBuffer_StoreToStreamPtr) dlsym(hLibrary, "libmcdriver_opencv_imagebuffer_storetostream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageBuffer_StoreToStream == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Mat_Empty = (PLibMCDriver_OpenCVMat_EmptyPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_mat_empty");
		#else // _WIN32
		pWrapperTable->m_Mat_Empty = (PLibMCDriver_OpenCVMat_EmptyPtr) dlsym(hLibrary, "libmcdriver_opencv_mat_empty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Mat_Empty == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Mat_Cols = (PLibMCDriver_OpenCVMat_ColsPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_mat_cols");
		#else // _WIN32
		pWrapperTable->m_Mat_Cols = (PLibMCDriver_OpenCVMat_ColsPtr) dlsym(hLibrary, "libmcdriver_opencv_mat_cols");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Mat_Cols == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Mat_Rows = (PLibMCDriver_OpenCVMat_RowsPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_mat_rows");
		#else // _WIN32
		pWrapperTable->m_Mat_Rows = (PLibMCDriver_OpenCVMat_RowsPtr) dlsym(hLibrary, "libmcdriver_opencv_mat_rows");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Mat_Rows == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Mat_EncodeImage = (PLibMCDriver_OpenCVMat_EncodeImagePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_mat_encodeimage");
		#else // _WIN32
		pWrapperTable->m_Mat_EncodeImage = (PLibMCDriver_OpenCVMat_EncodeImagePtr) dlsym(hLibrary, "libmcdriver_opencv_mat_encodeimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Mat_EncodeImage == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Mat_EncodeImageToStream = (PLibMCDriver_OpenCVMat_EncodeImageToStreamPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_mat_encodeimagetostream");
		#else // _WIN32
		pWrapperTable->m_Mat_EncodeImageToStream = (PLibMCDriver_OpenCVMat_EncodeImageToStreamPtr) dlsym(hLibrary, "libmcdriver_opencv_mat_encodeimagetostream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Mat_EncodeImageToStream == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_OpenCV_LoadImageFromBuffer = (PLibMCDriver_OpenCVDriver_OpenCV_LoadImageFromBufferPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_opencv_loadimagefrombuffer");
		#else // _WIN32
		pWrapperTable->m_Driver_OpenCV_LoadImageFromBuffer = (PLibMCDriver_OpenCVDriver_OpenCV_LoadImageFromBufferPtr) dlsym(hLibrary, "libmcdriver_opencv_driver_opencv_loadimagefrombuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_OpenCV_LoadImageFromBuffer == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_OpenCV_LoadImageFromResource = (PLibMCDriver_OpenCVDriver_OpenCV_LoadImageFromResourcePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_opencv_loadimagefromresource");
		#else // _WIN32
		pWrapperTable->m_Driver_OpenCV_LoadImageFromResource = (PLibMCDriver_OpenCVDriver_OpenCV_LoadImageFromResourcePtr) dlsym(hLibrary, "libmcdriver_opencv_driver_opencv_loadimagefromresource");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_OpenCV_LoadImageFromResource == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_OpenCV_CreateEmptyImage = (PLibMCDriver_OpenCVDriver_OpenCV_CreateEmptyImagePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_driver_opencv_createemptyimage");
		#else // _WIN32
		pWrapperTable->m_Driver_OpenCV_CreateEmptyImage = (PLibMCDriver_OpenCVDriver_OpenCV_CreateEmptyImagePtr) dlsym(hLibrary, "libmcdriver_opencv_driver_opencv_createemptyimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_OpenCV_CreateEmptyImage == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_OpenCVGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_OpenCVGetVersionPtr) dlsym(hLibrary, "libmcdriver_opencv_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_OpenCVGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_OpenCVGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_opencv_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_OpenCVReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_OpenCVReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_opencv_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_OpenCVAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_opencv_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_OpenCVAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_opencv_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_OpenCVInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_OpenCVInjectComponentPtr) dlsym(hLibrary, "libmcdriver_opencv_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_OpenCVGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_OpenCVGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_opencv_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_OpenCVCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_opencv_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_OpenCVCreateDriverPtr) dlsym(hLibrary, "libmcdriver_opencv_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_OPENCV_SUCCESS;
	}

	inline LibMCDriver_OpenCVResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_OpenCVDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_OpenCVResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_OpenCVResult eLookupError = LIBMCDRIVER_OPENCV_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_imagebuffer_getimageformat", (void**)&(pWrapperTable->m_ImageBuffer_GetImageFormat));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageBuffer_GetImageFormat == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_imagebuffer_getsize", (void**)&(pWrapperTable->m_ImageBuffer_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageBuffer_GetSize == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_imagebuffer_getdata", (void**)&(pWrapperTable->m_ImageBuffer_GetData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageBuffer_GetData == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_imagebuffer_storetostream", (void**)&(pWrapperTable->m_ImageBuffer_StoreToStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageBuffer_StoreToStream == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_mat_empty", (void**)&(pWrapperTable->m_Mat_Empty));
		if ( (eLookupError != 0) || (pWrapperTable->m_Mat_Empty == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_mat_cols", (void**)&(pWrapperTable->m_Mat_Cols));
		if ( (eLookupError != 0) || (pWrapperTable->m_Mat_Cols == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_mat_rows", (void**)&(pWrapperTable->m_Mat_Rows));
		if ( (eLookupError != 0) || (pWrapperTable->m_Mat_Rows == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_mat_encodeimage", (void**)&(pWrapperTable->m_Mat_EncodeImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Mat_EncodeImage == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_mat_encodeimagetostream", (void**)&(pWrapperTable->m_Mat_EncodeImageToStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Mat_EncodeImageToStream == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_opencv_loadimagefrombuffer", (void**)&(pWrapperTable->m_Driver_OpenCV_LoadImageFromBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_OpenCV_LoadImageFromBuffer == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_opencv_loadimagefromresource", (void**)&(pWrapperTable->m_Driver_OpenCV_LoadImageFromResource));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_OpenCV_LoadImageFromResource == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_driver_opencv_createemptyimage", (void**)&(pWrapperTable->m_Driver_OpenCV_CreateEmptyImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_OpenCV_CreateEmptyImage == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_opencv_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_OPENCV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_OPENCV_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_OpenCV_uint32 bytesNeededName = 0;
		LibMCDriver_OpenCV_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_OpenCV_uint32 bytesNeededType = 0;
		LibMCDriver_OpenCV_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_OpenCV_uint32 & nMajor, LibMCDriver_OpenCV_uint32 & nMinor, LibMCDriver_OpenCV_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_OpenCV_uint32 bytesNeededBuild = 0;
		LibMCDriver_OpenCV_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class CImageSaveParameters
	 */
	
	/**
	 * Method definitions for class CImageBuffer
	 */
	
	/**
	* CImageBuffer::GetImageFormat - Retrieves the image format of the encoded buffer.
	* @return Format to write to.
	*/
	eImageWriteFormat CImageBuffer::GetImageFormat()
	{
		eImageWriteFormat resultImageFormat = (eImageWriteFormat) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageBuffer_GetImageFormat(m_pHandle, &resultImageFormat));
		
		return resultImageFormat;
	}
	
	/**
	* CImageBuffer::GetSize - Retrieves the size of the encoded buffer.
	* @return Size of the buffer.
	*/
	LibMCDriver_OpenCV_uint64 CImageBuffer::GetSize()
	{
		LibMCDriver_OpenCV_uint64 resultBufferSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageBuffer_GetSize(m_pHandle, &resultBufferSize));
		
		return resultBufferSize;
	}
	
	/**
	* CImageBuffer::GetData - Retrieves the data of the encoded buffer.
	* @param[out] MemoryArrayBuffer - Array to write into.
	*/
	void CImageBuffer::GetData(std::vector<LibMCDriver_OpenCV_uint8> & MemoryArrayBuffer)
	{
		LibMCDriver_OpenCV_uint64 elementsNeededMemoryArray = 0;
		LibMCDriver_OpenCV_uint64 elementsWrittenMemoryArray = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageBuffer_GetData(m_pHandle, 0, &elementsNeededMemoryArray, nullptr));
		MemoryArrayBuffer.resize((size_t) elementsNeededMemoryArray);
		CheckError(m_pWrapper->m_WrapperTable.m_ImageBuffer_GetData(m_pHandle, elementsNeededMemoryArray, &elementsWrittenMemoryArray, MemoryArrayBuffer.data()));
	}
	
	/**
	* CImageBuffer::StoreToStream - Stores the data in a temporary file stream.
	* @param[in] pStream - Stream to store the data to.
	*/
	void CImageBuffer::StoreToStream(classParam<LibMCEnv::CTempStreamWriter> pStream)
	{
		LibMCEnvHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_ImageBuffer_StoreToStream(m_pHandle, hStream));
	}
	
	/**
	 * Method definitions for class CMat
	 */
	
	/**
	* CMat::Empty - Returns if the Mat instance is empty.
	* @return Returns true if the Mat instance is empty. False otherwise.
	*/
	bool CMat::Empty()
	{
		bool resultIsEmpty = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Mat_Empty(m_pHandle, &resultIsEmpty));
		
		return resultIsEmpty;
	}
	
	/**
	* CMat::Cols - Returns the number of columns.
	* @return Returns the number of columns of the matrix.
	*/
	LibMCDriver_OpenCV_uint32 CMat::Cols()
	{
		LibMCDriver_OpenCV_uint32 resultNumberOfColumns = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Mat_Cols(m_pHandle, &resultNumberOfColumns));
		
		return resultNumberOfColumns;
	}
	
	/**
	* CMat::Rows - Returns the number of rows.
	* @return Returns the number of rows of the matrix.
	*/
	LibMCDriver_OpenCV_uint32 CMat::Rows()
	{
		LibMCDriver_OpenCV_uint32 resultNumberOfRows = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Mat_Rows(m_pHandle, &resultNumberOfRows));
		
		return resultNumberOfRows;
	}
	
	/**
	* CMat::EncodeImage - Writes a matrix as image buffer.
	* @param[in] eWriteFormat - Format to write to.
	* @param[in] pSaveParameters - Optional parameters for writing the image file.
	* @return Returns an image buffer object.
	*/
	PImageBuffer CMat::EncodeImage(const eImageWriteFormat eWriteFormat, classParam<CImageSaveParameters> pSaveParameters)
	{
		LibMCDriver_OpenCVHandle hSaveParameters = pSaveParameters.GetHandle();
		LibMCDriver_OpenCVHandle hOutputBuffer = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Mat_EncodeImage(m_pHandle, eWriteFormat, hSaveParameters, &hOutputBuffer));
		
		if (!hOutputBuffer) {
			CheckError(LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageBuffer>(m_pWrapper, hOutputBuffer);
	}
	
	/**
	* CMat::EncodeImageToStream - Writes a matrix into a temporary file stream.
	* @param[in] eWriteFormat - Format to write to.
	* @param[in] pSaveParameters - Optional parameters for writing the image file.
	* @param[in] pStream - Stream to store the data to.
	*/
	void CMat::EncodeImageToStream(const eImageWriteFormat eWriteFormat, classParam<CImageSaveParameters> pSaveParameters, classParam<LibMCEnv::CTempStreamWriter> pStream)
	{
		LibMCDriver_OpenCVHandle hSaveParameters = pSaveParameters.GetHandle();
		LibMCEnvHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Mat_EncodeImageToStream(m_pHandle, eWriteFormat, hSaveParameters, hStream));
	}
	
	/**
	 * Method definitions for class CDriver_OpenCV
	 */
	
	/**
	* CDriver_OpenCV::LoadImageFromBuffer - Loads an image from a memory buffer.
	* @param[in] BufferBuffer - Image data to read from.
	* @param[in] eReadFormat - Image format to output.
	* @return Mat instance of the image that has been loaded.
	*/
	PMat CDriver_OpenCV::LoadImageFromBuffer(const CInputVector<LibMCDriver_OpenCV_uint8> & BufferBuffer, const eImageReadFormat eReadFormat)
	{
		LibMCDriver_OpenCVHandle hMatInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_OpenCV_LoadImageFromBuffer(m_pHandle, (LibMCDriver_OpenCV_uint64)BufferBuffer.size(), BufferBuffer.data(), eReadFormat, &hMatInstance));
		
		if (!hMatInstance) {
			CheckError(LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMat>(m_pWrapper, hMatInstance);
	}
	
	/**
	* CDriver_OpenCV::LoadImageFromResource - Loads an image from a resource identifier.
	* @param[in] sResourceIdentifier - Image resource to read from.
	* @param[in] eReadFormat - Image format to output.
	* @return Mat instance of the image that has been loaded.
	*/
	PMat CDriver_OpenCV::LoadImageFromResource(const std::string & sResourceIdentifier, const eImageReadFormat eReadFormat)
	{
		LibMCDriver_OpenCVHandle hMatInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_OpenCV_LoadImageFromResource(m_pHandle, sResourceIdentifier.c_str(), eReadFormat, &hMatInstance));
		
		if (!hMatInstance) {
			CheckError(LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMat>(m_pWrapper, hMatInstance);
	}
	
	/**
	* CDriver_OpenCV::CreateEmptyImage - Creates an empty image.
	* @param[in] nColumnCount - Number of Column of the new image.
	* @param[in] nRowCount - Number of Rows of the new image.
	* @param[in] eReadFormat - Image format to output.
	* @return Mat instance of the image that has been loaded.
	*/
	PMat CDriver_OpenCV::CreateEmptyImage(const LibMCDriver_OpenCV_uint32 nColumnCount, const LibMCDriver_OpenCV_uint32 nRowCount, const eImageReadFormat eReadFormat)
	{
		LibMCDriver_OpenCVHandle hMatInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_OpenCV_CreateEmptyImage(m_pHandle, nColumnCount, nRowCount, eReadFormat, &hMatInstance));
		
		if (!hMatInstance) {
			CheckError(LIBMCDRIVER_OPENCV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMat>(m_pWrapper, hMatInstance);
	}

} // namespace LibMCDriver_OpenCV

#endif // __LIBMCDRIVER_OPENCV_CPPHEADER_DYNAMIC_CPP

